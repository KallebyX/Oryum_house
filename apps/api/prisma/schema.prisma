// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

// Enums
enum UserRole {
  ADMIN_GLOBAL
  SINDICO
  ZELADOR
  PORTARIA
  MORADOR
}

enum TicketStatus {
  NOVA
  EM_AVALIACAO
  EM_ANDAMENTO
  AGUARDANDO_MORADOR
  CONCLUIDA
  CANCELADA
}

enum TicketPriority {
  BAIXA
  MEDIA
  ALTA
}

enum TicketCategory {
  ELETRICA
  HIDRAULICA
  LIMPEZA
  SEGURANCA
  OUTROS
}

enum BookingStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELED
}

enum AssemblyStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELED
}

enum IncidentType {
  SEGURANCA
  BARULHO
  VAZAMENTO
  MANUTENCAO
  OUTROS
}

enum IncidentStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum NotificationType {
  TICKET_UPDATE
  NEW_NOTICE
  ASSEMBLY_REMINDER
  BOOKING_APPROVED
  DELIVERY_RECEIVED
  VISITOR_ARRIVED
  MAINTENANCE_SCHEDULED
  INCIDENT_REPORTED
}

// Models
model User {
  id           String    @id @default(cuid())
  email        String    @unique
  name         String
  phone        String?
  passwordHash String
  avatarUrl    String?
  isActive     Boolean   @default(true)
  lastLoginAt  DateTime?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  memberships           Membership[]
  ownedUnits            Unit[]                  @relation("UnitOwner")
  occupiedUnits         Unit[]                  @relation("UnitOccupants")
  openedTickets         Ticket[]                @relation("TicketOpener")
  assignedTickets       Ticket[]                @relation("TicketAssignee")
  ticketComments        TicketComment[]
  ticketStatusHistory   TicketStatusHistory[]
  bookings              Booking[]
  noticeReadConfirms    NoticeReadConfirmation[]
  votes                 Vote[]
  deliveries            Delivery[]              @relation("DeliveryPicker")
  createdDocuments      Document[]
  createdMaintenancePlan MaintenancePlan[]
  reportedIncidents     Incident[]
  notifications         Notification[]
  auditLogs             AuditLog[]
  // Gamificação
  points                UserPoints[]
  achievements          UserAchievement[]
  pointHistory          PointHistory[]

  @@map("users")
}

model Condominium {
  id       String @id @default(cuid())
  name     String
  cnpj     String?
  street   String
  number   String
  district String
  city     String
  state    String
  cep      String
  logoUrl  String?
  settings Json?
  isActive Boolean @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  memberships      Membership[]
  units            Unit[]
  tickets          Ticket[]
  areas            Area[]
  bookings         Booking[]
  notices          Notice[]
  assemblies       Assembly[]
  deliveries       Delivery[]
  visitorPasses    VisitorPass[]
  documents        Document[]
  maintenancePlans MaintenancePlan[]
  incidents        Incident[]
  auditLogs        AuditLog[]
  // Gamificação
  userPoints       UserPoints[]
  achievements     Achievement[]
  pointHistories   PointHistory[]

  @@map("condominiums")
}

model Unit {
  id            String  @id @default(cuid())
  condominiumId String
  block         String
  number        String
  areaM2        Float?
  isActive      Boolean @default(true)
  ownerId       String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  condominium   Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  owner         User?       @relation("UnitOwner", fields: [ownerId], references: [id])
  occupants     User[]      @relation("UnitOccupants")
  tickets       Ticket[]
  bookings      Booking[]
  deliveries    Delivery[]
  visitorPasses VisitorPass[]

  @@unique([condominiumId, block, number])
  @@map("units")
}

model Membership {
  id            String   @id @default(cuid())
  userId        String
  condominiumId String
  role          UserRole
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)

  @@unique([userId, condominiumId])
  @@map("memberships")
}

model Ticket {
  id                String         @id @default(cuid())
  condominiumId     String
  unitId            String?
  openedById        String
  assignedToId      String?
  category          TicketCategory
  priority          TicketPriority @default(MEDIA)
  status            TicketStatus   @default(NOVA)
  slaHours          Int            @default(24)
  title             String
  description       String
  location          String?
  tags              String[]
  checklist         Json?
  satisfactionScore Int?
  closedAt          DateTime?
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  // Relations
  condominium   Condominium           @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  unit          Unit?                 @relation(fields: [unitId], references: [id])
  openedBy      User                  @relation("TicketOpener", fields: [openedById], references: [id])
  assignedTo    User?                 @relation("TicketAssignee", fields: [assignedToId], references: [id])
  statusHistory TicketStatusHistory[]
  comments      TicketComment[]
  attachments   TicketAttachment[]

  @@index([condominiumId, status])
  @@index([condominiumId, priority])
  @@index([condominiumId, category])
  @@index([condominiumId, assignedToId])
  @@map("tickets")
}

model TicketStatusHistory {
  id       String       @id @default(cuid())
  ticketId String
  fromStatus TicketStatus?
  toStatus TicketStatus
  byUserId String
  note     String?
  createdAt DateTime     @default(now())

  // Relations
  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  byUser User   @relation(fields: [byUserId], references: [id])

  @@map("ticket_status_history")
}

model TicketComment {
  id          String   @id @default(cuid())
  ticketId    String
  authorId    String
  message     String
  mentions    String[]
  attachments String[]
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  author User   @relation(fields: [authorId], references: [id])

  @@map("ticket_comments")
}

model TicketAttachment {
  id       String @id @default(cuid())
  ticketId String
  filename String
  fileUrl  String
  fileSize Int
  mimeType String
  createdAt DateTime @default(now())

  // Relations
  ticket Ticket @relation(fields: [ticketId], references: [id], onDelete: Cascade)

  @@map("ticket_attachments")
}

model Area {
  id               String  @id @default(cuid())
  condominiumId    String
  name             String
  description      String?
  rules            String?
  capacity         Int?
  requiresApproval Boolean @default(false)
  feePlaceholder   Float?
  isActive         Boolean @default(true)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  bookings    Booking[]

  @@map("areas")
}

model Booking {
  id            String        @id @default(cuid())
  condominiumId String
  areaId        String
  unitId        String
  requestedById String
  startAt       DateTime
  endAt         DateTime
  status        BookingStatus @default(PENDING)
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  // Relations
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  area        Area        @relation(fields: [areaId], references: [id])
  unit        Unit        @relation(fields: [unitId], references: [id])
  requestedBy User        @relation(fields: [requestedById], references: [id])

  @@index([condominiumId, areaId, startAt])
  @@map("bookings")
}

model Notice {
  id            String                   @id @default(cuid())
  condominiumId String
  title         String
  content       String
  audience      String                   @default("ALL") // ALL, BLOCK, UNIT
  audienceFilter Json?                   // specific blocks/units
  pinned        Boolean                  @default(false)
  publishedAt   DateTime?
  expiresAt     DateTime?
  createdAt     DateTime                 @default(now())
  updatedAt     DateTime                 @updatedAt

  // Relations
  condominium      Condominium              @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  readConfirmations NoticeReadConfirmation[]

  @@index([condominiumId, publishedAt])
  @@map("notices")
}

model NoticeReadConfirmation {
  id       String   @id @default(cuid())
  noticeId String
  userId   String
  readAt   DateTime @default(now())

  // Relations
  notice Notice @relation(fields: [noticeId], references: [id], onDelete: Cascade)
  user   User   @relation(fields: [userId], references: [id])

  @@unique([noticeId, userId])
  @@map("notice_read_confirmations")
}

model Assembly {
  id           String          @id @default(cuid())
  condominiumId String
  title        String
  agenda       Json
  startAt      DateTime
  endAt        DateTime
  quorumTarget Int
  status       AssemblyStatus  @default(SCHEDULED)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  // Relations
  condominium Condominium    @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  items       AssemblyItem[]
  votes       Vote[]

  @@map("assemblies")
}

model AssemblyItem {
  id         String @id @default(cuid())
  assemblyId String
  title      String
  description String?
  order      Int
  options    Json   // Array of voting options
  createdAt  DateTime @default(now())

  // Relations
  assembly Assembly @relation(fields: [assemblyId], references: [id], onDelete: Cascade)
  votes    Vote[]

  @@map("assembly_items")
}

model Vote {
  id       String   @id @default(cuid())
  assemblyId String
  itemId   String
  userId   String
  optionId String
  votedAt  DateTime @default(now())

  // Relations
  assembly Assembly     @relation(fields: [assemblyId], references: [id], onDelete: Cascade)
  item     AssemblyItem @relation(fields: [itemId], references: [id], onDelete: Cascade)
  user     User         @relation(fields: [userId], references: [id])

  @@unique([assemblyId, itemId, userId])
  @@map("votes")
}

model Delivery {
  id            String    @id @default(cuid())
  condominiumId String
  unitId        String
  code          String    @unique
  carrier       String?
  description   String?
  receivedAt    DateTime  @default(now())
  pickedUpAt    DateTime?
  pickedById    String?
  notes         String?

  // Relations
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  unit        Unit        @relation(fields: [unitId], references: [id])
  pickedBy    User?       @relation("DeliveryPicker", fields: [pickedById], references: [id])

  @@index([condominiumId, unitId])
  @@map("deliveries")
}

model VisitorPass {
  id            String    @id @default(cuid())
  condominiumId String
  unitId        String
  visitorName   String
  document      String?
  qrToken       String    @unique
  validFrom     DateTime
  validTo       DateTime
  usedAt        DateTime?
  createdAt     DateTime  @default(now())

  // Relations
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  unit        Unit        @relation(fields: [unitId], references: [id])

  @@index([condominiumId, validFrom, validTo])
  @@map("visitor_passes")
}

model Document {
  id            String   @id @default(cuid())
  condominiumId String
  title         String
  version       String   @default("1.0")
  fileUrl       String
  fileSize      Int
  mimeType      String
  visibility    String   @default("ALL") // ALL, ROLE, UNIT
  visibilityFilter Json?
  createdById   String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  createdBy   User        @relation(fields: [createdById], references: [id])

  @@map("documents")
}

model MaintenancePlan {
  id            String   @id @default(cuid())
  condominiumId String
  title         String
  description   String?
  schedule      String   // RRULE format
  tasks         Json
  responsibleId String?
  nextRunAt     DateTime?
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  responsible User?       @relation(fields: [responsibleId], references: [id])
  executions  MaintenanceExecution[]

  @@map("maintenance_plans")
}

model MaintenanceExecution {
  id        String   @id @default(cuid())
  planId    String
  executedAt DateTime @default(now())
  notes     String?
  completed Boolean  @default(false)

  // Relations
  plan MaintenancePlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@map("maintenance_executions")
}

model Incident {
  id            String         @id @default(cuid())
  condominiumId String
  type          IncidentType
  title         String
  description   String
  reportedById  String
  status        IncidentStatus @default(OPEN)
  attachments   String[]
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  // Relations
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  reportedBy  User        @relation(fields: [reportedById], references: [id])

  @@index([condominiumId, status])
  @@map("incidents")
}

model Notification {
  id      String           @id @default(cuid())
  userId  String
  type    NotificationType
  title   String
  message String
  payload Json?
  readAt  DateTime?
  createdAt DateTime       @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
  @@map("notifications")
}

model AuditLog {
  id            String    @id @default(cuid())
  actorId       String?
  condominiumId String?
  entity        String
  entityId      String
  action        String    // CREATE, UPDATE, DELETE
  diff          Json?
  ip            String?
  userAgent     String?
  createdAt     DateTime  @default(now())

  // Relations
  actor       User?        @relation(fields: [actorId], references: [id])
  condominium Condominium? @relation(fields: [condominiumId], references: [id], onDelete: Cascade)

  @@index([condominiumId, entity, createdAt])
  @@index([actorId, createdAt])
  @@map("audit_logs")
}

// ==========================================
// GAMIFICAÇÃO - Sistema de Pontos e Conquistas
// ==========================================

enum AchievementCategory {
  PARTICIPATION  // Participação em assembleias, leitura de comunicados
  COMMUNITY      // Ações comunitárias
  PUNCTUALITY    // Pontualidade em pagamentos, reservas
  SUPPORT        // Ajuda a outros moradores
  SPECIAL        // Conquistas especiais
}

// Pontos do usuário por condomínio
model UserPoints {
  id            String   @id @default(cuid())
  userId        String
  condominiumId String
  points        Int      @default(0)
  level         Int      @default(1)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)

  @@unique([userId, condominiumId])
  @@index([condominiumId, points])
  @@map("user_points")
}

// Conquistas disponíveis
model Achievement {
  id            String              @id @default(cuid())
  condominiumId String?             // null = conquista global
  key           String              @unique // identificador único (ex: FIRST_TICKET, ASSEMBLY_VOTER_10X)
  name          String
  description   String
  category      AchievementCategory
  icon          String?
  points        Int                 @default(0)
  requirement   Json                // Condições para desbloquear
  isActive      Boolean             @default(true)
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  // Relations
  condominium      Condominium?       @relation(fields: [condominiumId], references: [id], onDelete: Cascade)
  userAchievements UserAchievement[]

  @@map("achievements")
}

// Conquistas desbloqueadas pelos usuários
model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime @default(now())

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@map("user_achievements")
}

// Histórico de pontuação
model PointHistory {
  id            String   @id @default(cuid())
  userId        String
  condominiumId String
  points        Int      // Pode ser positivo ou negativo
  reason        String
  entityType    String?  // TICKET, NOTICE, ASSEMBLY, VOTE, etc.
  entityId      String?
  createdAt     DateTime @default(now())

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  condominium Condominium @relation(fields: [condominiumId], references: [id], onDelete: Cascade)

  @@index([userId, condominiumId, createdAt])
  @@map("point_history")
}
